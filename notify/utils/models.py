
# ContenType
from django.contrib.contenttypes.models import ContentType
from django.contrib.contenttypes.fields import GenericForeignKey

#Timezone
from django.utils import timezone

# Models
from accounts.models import User as Usuario

#Django
from django.db import models
from django.contrib.auth.models import Group
from django.db.models.query import QuerySet

#signals
from notify.signals import notificar

#swapper
from swapper import load_model

class NotificationQueryset(models.QuerySet):

	def leido(self):
		"""
			Retornamos las notificaciones que hayan sido leidas en el actual Queryset
		"""
		return self.filter(read=True)

	def no_leido(self):
		"""
			Retornamos solo los items que no hayan sido leidos en el actual Queryset
		"""	
		return self.filter(read=False)

	def marcar_todo_as_leido(self, destiny=None):
		"""
			Marcar todas las notify como leidas en el actual queryset
		"""
		qs = self.read(False)
		if destiny:
			qs = qs.filter(destiny=destiny)

		return qs.update(read=True)

	def marcar_todo_as_no_leido(self, destiny=None):
		"""
			Marcar todas las notificaciones como no leidas en el actual queryset
		"""

		qs = self.read(True)
		if destiny:
			qs = qs.filter(destiny=destiny)

		return qs.update(read=False)



class AbstractNotificationManager(models.Manager):
	def get_queryset(self):
		return self.NotificationQueryset(self.Model, using=self._db)

class AbstractNotificacion(models.Model):

	class Levels(models.TextChoices):
		success = 'Success', 'success',
		info = 'Info', 'info',
		wrong = 'Wrong', 'wrong'
  
	class Tipo(models.TextChoices):
		tutoria = 'tutoria',
		orientacion = 'orientacion',
		cita_orientacion = 'cita_orientacion',
		cita_tutoria = 'cita_tutoria',
		tarea_tutoria = 'tarea_tutoria',
		tarea_orientacion = 'tarea_orientacion',
		tarea_cita_tutoria = 'tarea_cita_tutoria',
		tarea_cita_orientacion = 'tarea_cita_orientacion',

	level = models.CharField(choices=Levels.choices, max_length=20, default=Levels.info)
	tipo = models.CharField(choices=Tipo.choices, max_length=25, default= Tipo.tutoria)
	
	id_tipo= models.IntegerField(default=0)

	destiny = models.ForeignKey(Usuario, on_delete=models.CASCADE, related_name='notificaciones', blank=True, null=True)

	actor_content_type = models.ForeignKey(ContentType, related_name='notificar_actor', on_delete=models.CASCADE)
	object_id_actor = models.PositiveIntegerField()
	actor = GenericForeignKey('actor_content_type', 'object_id_actor')

	verbo = models.CharField(max_length=220)

	read = models.BooleanField(default=False)
	publico = models.BooleanField(default=True)
	eliminado = models.BooleanField(default=False)

	timestamp = models.DateTimeField(default=timezone.now, db_index=True)

	objects = NotificationQueryset.as_manager()

	class Meta:
		abstract = True
	
	def __str__(self):
		return "Actor: {} --- Destiny: {} --- Verb: {}".format(self.actor, self.destiny, self.verbo)
  
  
def notify_signals(verb, **kwargs):
	"""
		Funcion de controlador para crear una instancia de notificacion
		tras una llamada de signal de accion
	"""
	destiny= kwargs.pop('destiny')
	actor= kwargs.pop('sender')
	publico= bool(kwargs.pop('publico', True))
	timestamp= kwargs.pop('timestamp', timezone.now())

	Notify = load_model('notify', 'Notification')
	levels= kwargs.pop('level', Notify.Levels.info)

	if isinstance(destiny, Group):
		destinies= destiny.user_set.all()
	elif isinstance(destiny, (QuerySet, list)):
		destinies= destiny
	else:
		destinies= [destiny]

	new_notify= []
	for destiny in destinies:
		notification= Notify(destiny= destiny, actor_content_type= ContentType.objects.get_for_model(actor), object_id_actor= actor.pk, verbo= str(verb), publico= publico, timestamp= timestamp, level= levels)
		notification.save()
		new_notify.append(notification)

	return new_notify


notificar.connect(notify_signals, dispatch_uid='notify.models.Notification')